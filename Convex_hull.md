## Convex_hull
### CCW(Counter_clockwise)
* 어떤 벡터v1에서 다른 벡터 v2로 회전 시 반시계 방향(왼쪽)으로 회전하면 ccw > 0이고 시계 방향(오른쪽)으로 회전하면 ccw < 0이다.

### Brute Force - 1
* 점 n개가 있을때 모든 점에 대한 선분은 n^2개 이다. 이 모든 선분에 대해서 CCW을 이용해서 convex hull 경계인지 확인하면 n이므로 시간복잡도는 O(n^3)이 된다. 

### Brute Force - 2
* 모든 점에 대해서 다른 점으로 가는 선분을 다 긋는다. > n^2
ccw을 이용해서 이 선분들을 각도순으로 sorting한다. 
O(n^2(logn)) 

### Package Wrapping
y좌표가 제일 작은 점부터 시작한다(n). 이 점에서 모든 점으로 선분을 다 그은 다음에 ccw을 이용해서 제일 오른쪽에 있는 선분을 찾는다.  n^2
즉, n + n^2

### Gram Scan
y좌표가 제일 작은 점P 부터 시작한다. > O(n)   
점들의 집합을 점 P로부터 x축에 대해 각도가 증가하는 순으로 정렬한다. > O(nlogn)

Convex hull stack이 있다고 하자.   
항상 stack의 제일 위에 점을 s, 제일 위에서 두 번째 있는 점을 f라고 하고 현재 알고리즘이 고려해야 할 점을 t라고 하자.   
점 f, 점 s, 점 t를 잇는 두 선분의 ccw의 값이 양수(좌회전)이라면 점 t를 stack에 넣는다.
만약 두 선분의 ccw의 값이 음수(우회전)이라면 점 f, 점 s, 점 t에 대한 ccw값이 양수가 나올 때까지 stack을 계속 pop한다.   
ccw값이 양수가 되는 점s를 찾으면 t를 stack에 넣는다. > O(n)

이렇게 convex hull을 만든다.

n + nlogn + n

1. convex hull stack을 S라고 하자.
2. S의 제일 위에있는 점을 t라고하자.
3. t의 직전 점 - t - c로 가는 두 직선의 ccw값이 양수가 될때까지 s를 pop한다
4. ccw값이 양수가 되는 t를 찾았으면 c를 스택에 넣는다


## Plan Sweeping (귀납법 문제로 나올 수 있음)
i번째로 왼쪽에 있는 점을 i라고 하자. i이전에 점들에 대해서 convex hull이 있다고 가정할 때 i를 포함하는 새로운 convex hull을 만드는 것이 메커니즘이다.  
n번 까지 알고리즘을 수행하여 점 n개에 대한 convex hull이 있을 때 n+1번째에 추가하는 새로운 점에서 convex hull로 이어지는 두 접선을 찾아서 두 접선이 생기는 convex hull 부분의 두 점 사이의 점(오른쪽에 있는)은 convex hull에서 제외되고 n+1번째 점을 추가한다. 

접선은 새로운점 > 접점 > 접점이후의 점 의 ccw값과 새로운 점 > 접점 >접점이전의 점 ccw값이 부호가 같을 때 
* Binary Search로 접점을 첮을 수 있다.(엄밀히 말하면 새로운 점에서 두번의 이진 탐색이 일어남.)

따라서 점 n개에 대해 binary search가 일어났으므로 O(nlogn)

### Dynamic case (Incremented)
아무점에나 시작해서(점 3개 이하는 convex hull이 그냥 만들어짐) 어느 한 점에서 뻗었을 때 (y좌표로 확인한다.)양쪽에서 만나면 내부에 있는 점이므로 plane swweping을 수행하지 않고 그렇지 않고 외부이면 plane sweeping 수행한다.

### Divid and Conquer (Upper Hull only)
a. 왼쪽 Hull, 오른쪽 Hull이 있을 때, 한 쪽(설명의 편의를 위해 왼쪽으로 가정한다.) Hull의 한 점(L)에서 반대 쪽 Hull(오른쪽 Hull)의 점들의 배열을 모두 확인한다.
b. 배열의 이전 원소가 우회전(ccw < 0), 앞에 원소가 좌회전(ccw > 0)이면 두 Hull을 잇는 선분은 오른쪽 Hull을 뚫고 들어가고 배열의 이전 원소가 좌회전, 앞에 원소가 우회전이면 배열을 뚫고 나간다.
c. 이렇게 해서 접점(R)을 찾으면(오른쪽 Hull에서 한 점과 이전 점, 다음 점 둘다 우회전일 때[부호가 같을 때]) 공통 접선인지 확인한다.
d. 접점을 찾은 오른쪽 Hull에서 왼쪽 Hull 점을 봤을 때 b,c 방법으로 확인해서 부호가 같으면 공통 접선이다.
e. 공통 접선이 아니라면 L의 다음 점에서 다시 오른쪽 Hull의 공통 접선을 찾는다. 이때 접점은 R 오른쪽에서 찾는다.   
f. 공통 접선을 찾으면 두 convex Hull을 이어주면 된다.   
이렇게 하면 총 O(n)의 시간이 걸린다.

> 따라서 Divid한 것에 logn이 걸리고 공통접선을 찾는데 O(n)
이므로 총 O(nlogn)이 소요된다.

#### binary search로 공통 접선 찾기.
a. 왼쪽 Hull 배열 중간 점에서 이진 탐색으로 오른쪽 Hull 배열에 접선을 찾는다.
b. 찾았으면 반대편 왼쪽 Hull 배열의 그 점도 접선이 되는지 확인한다.
c. 반대편 점이 접선이 아니면 왼쪽 Hull 배열에서 이진 탐색을 1회 진행한다.
d. 다시 오른쪽 Hull에서 접전을 찾는다.
이렇게 반복되면 총 O(log^2n) 시간이 소요된다.  

결국에는 nlogn을 넘을 수 없긴 함.
(결국 두 hull을 배열에 넣어야 해서 +n이 되어서 ...?)